# Reproducing the Documentation Demo
In this test of circom, I reproduce the demo of the Documentation. It involves writing a template which contains the input and output signals of a circuit followed by the computations on the input signal which eventually lead to the output signal.

## Stack used
1. Windows Subsystem Linux
2. Circom 2.0
3. SnarkJS

## Observations
The following observations were made while trying this demo out:
- Consider the circuit as a black-box. Input signals feed into the black box and output signals come out of it.
- Templates are to Components what Classes are to Object in OOP
- General convention when declaring signals is `signal <input/output> <identifier>` for eg, `signal input a;` will define an input signal `a` while `signal output out[N]` will define an output `out` which is an array of `N` elements
- All signals in a template are private
- To make a circuit, create a Component from a template by `component <component name> <(optional) define viewing scope of the signals> = <template name>` for eg, `component main {public [in1, in2]} = Multiplier()` would define a circuit called `main` from the `Multiplier()` template which has two public inputs `in1` and `in2`. If template `Multipler()` has other input signals within it then they will be considered as private
- templates can be nested inside templates by creating component of the template to be nested inside the template which should nest it
- let's say that `c1` is a component inside a template `t1` and `c1` contains an input signal `a`. Then `c1.a <== t1.in1` will generate a constraint and assign `in1` to `a` where `in1` is the input signal of `t1`

- `circom` is used for writing the circuit, compiling the circuit and computing a witness from a user provided `input.json` file. This would generate a binary encoded Witness file with extension `.wtns` which will be used in `snarkjs` to create the proofs.

- In our circuit, we try to factorize 33 and prove that we know two number which can be multiplied to obtain 33

## For Verifier Contract
The Verifier contract has been deployed and verfied at this address. Please note the following as the arguments to the `verifyProof()` function:
```
 a = ["0x2c30ab38bf42bad228bf782bae2d0ce81afea6207e6fe3802af68719f66c136d","0x005a2f383a33a98033dfc4b81284e6d116b99963cd0c6f5a1e1c27fc3f4da921"]

 b = [["0x2d38fafc20a0e386b91e61896d30a5ac490c93630340b19c75dbd486000c4d77","0x0d0d0fec2c1ef0c082159443ef97e025190c738726c019046a9739ec39988efa"],["0x2b55f7fdebad88ac9e282ed97c329dfd1a68b84f89099a563487873dce8e4e73","0x1289396c193fdbc1c61829623d1abc6638f9a140610a3559d77a9cf66d4b8314"]]

 c = ["0x2e15a28be26a7053e542665d33d68b03eedbae2aae55f1a9bb270b4fe30b56e2", "0x292378e5c48e19169eca3402e61e820d6f01515df9bdc901f5bf838a5e824923"]

 input = ["0x000000000000000000000000000000
0000000000000000000000000000000021"]

```

The above are generated by invoking `snarkjs generatecall` after the verifier contract was created using `snarkjs zkey export solidityverifier multiplier_0001.zkey verifier.sol`. It uses `public.json` to create the inputs to pass into the function.